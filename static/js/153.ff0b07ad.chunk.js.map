{"version":3,"file":"static/js/153.ff0b07ad.chunk.js","mappings":"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","sources":["../node_modules/reselect/src/utils.ts","../node_modules/reselect/src/autotrackMemoize/proxy.ts","../node_modules/reselect/src/weakMapMemoize.ts","../node_modules/reselect/src/createSelectorCreator.ts","../node_modules/reselect/src/createStructuredSelector.ts","redux/main-component/selector.ts","components/searchBar/index.tsx","components/table/detailedView.tsx","components/table/index.tsx","containers/main-component/index.tsx"],"sourcesContent":["import { runIdentityFunctionCheck } from './devModeChecks/identityFunctionCheck'\r\nimport { runInputStabilityCheck } from './devModeChecks/inputStabilityCheck'\r\nimport { globalDevModeChecks } from './devModeChecks/setGlobalDevModeChecks'\r\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\r\nimport type {\r\n  DevModeChecks,\r\n  Selector,\r\n  SelectorArray,\r\n  DevModeChecksExecutionInfo\r\n} from './types'\r\n\r\nexport const NOT_FOUND = /* @__PURE__ */ Symbol('NOT_FOUND')\r\nexport type NOT_FOUND_TYPE = typeof NOT_FOUND\r\n\r\n/**\r\n * Assert that the provided value is a function. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param func - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsFunction<FunctionType extends Function>(\r\n  func: unknown,\r\n  errorMessage = `expected a function, instead received ${typeof func}`\r\n): asserts func is FunctionType {\r\n  if (typeof func !== 'function') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided value is an object. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param object - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsObject<ObjectType extends Record<string, unknown>>(\r\n  object: unknown,\r\n  errorMessage = `expected an object, instead received ${typeof object}`\r\n): asserts object is ObjectType {\r\n  if (typeof object !== 'object') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided array is an array of functions. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param array - The array to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsArrayOfFunctions<FunctionType extends Function>(\r\n  array: unknown[],\r\n  errorMessage = `expected all items to be functions, instead received the following types: `\r\n): asserts array is FunctionType[] {\r\n  if (\r\n    !array.every((item): item is FunctionType => typeof item === 'function')\r\n  ) {\r\n    const itemTypes = array\r\n      .map(item =>\r\n        typeof item === 'function'\r\n          ? `function ${item.name || 'unnamed'}()`\r\n          : typeof item\r\n      )\r\n      .join(', ')\r\n    throw new TypeError(`${errorMessage}[${itemTypes}]`)\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure that the input is an array. If it's already an array, it's returned as is.\r\n * If it's not an array, it will be wrapped in a new array.\r\n *\r\n * @param item - The item to be checked.\r\n * @returns An array containing the input item. If the input is already an array, it's returned without modification.\r\n */\r\nexport const ensureIsArray = (item: unknown) => {\r\n  return Array.isArray(item) ? item : [item]\r\n}\r\n\r\n/**\r\n * Extracts the \"dependencies\" / \"input selectors\" from the arguments of `createSelector`.\r\n *\r\n * @param createSelectorArgs - Arguments passed to `createSelector` as an array.\r\n * @returns An array of \"input selectors\" / \"dependencies\".\r\n * @throws A `TypeError` if any of the input selectors is not function.\r\n */\r\nexport function getDependencies(createSelectorArgs: unknown[]) {\r\n  const dependencies = Array.isArray(createSelectorArgs[0])\r\n    ? createSelectorArgs[0]\r\n    : createSelectorArgs\r\n\r\n  assertIsArrayOfFunctions<Selector>(\r\n    dependencies,\r\n    `createSelector expects all input-selectors to be functions, but received the following types: `\r\n  )\r\n\r\n  return dependencies as SelectorArray\r\n}\r\n\r\n/**\r\n * Runs each input selector and returns their collective results as an array.\r\n *\r\n * @param dependencies - An array of \"dependencies\" or \"input selectors\".\r\n * @param inputSelectorArgs - An array of arguments being passed to the input selectors.\r\n * @returns An array of input selector results.\r\n */\r\nexport function collectInputSelectorResults(\r\n  dependencies: SelectorArray,\r\n  inputSelectorArgs: unknown[] | IArguments\r\n) {\r\n  const inputSelectorResults = []\r\n  const { length } = dependencies\r\n  for (let i = 0; i < length; i++) {\r\n    // @ts-ignore\r\n    // apply arguments instead of spreading and mutate a local list of params for performance.\r\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs))\r\n  }\r\n  return inputSelectorResults\r\n}\r\n\r\n/**\r\n * Retrieves execution information for development mode checks.\r\n *\r\n * @param devModeChecks - Custom Settings for development mode checks. These settings will override the global defaults.\r\n * @param firstRun - Indicates whether it is the first time the selector has run.\r\n * @returns  An object containing the execution information for each development mode check.\r\n */\r\nexport const getDevModeChecksExecutionInfo = (\r\n  firstRun: boolean,\r\n  devModeChecks: Partial<DevModeChecks>\r\n) => {\r\n  const { identityFunctionCheck, inputStabilityCheck } = {\r\n    ...globalDevModeChecks,\r\n    ...devModeChecks\r\n  }\r\n  return {\r\n    identityFunctionCheck: {\r\n      shouldRun:\r\n        identityFunctionCheck === 'always' ||\r\n        (identityFunctionCheck === 'once' && firstRun),\r\n      run: runIdentityFunctionCheck\r\n    },\r\n    inputStabilityCheck: {\r\n      shouldRun:\r\n        inputStabilityCheck === 'always' ||\r\n        (inputStabilityCheck === 'once' && firstRun),\r\n      run: runInputStabilityCheck\r\n    }\r\n  } satisfies DevModeChecksExecutionInfo\r\n}\r\n","// Original source:\r\n// - https://github.com/simonihmig/tracked-redux/blob/master/packages/tracked-redux/src/-private/proxy.ts\r\n\r\nimport type { Node, Tag } from './tracking'\r\nimport {\r\n  consumeCollection,\r\n  consumeTag,\r\n  createTag,\r\n  dirtyCollection,\r\n  dirtyTag\r\n} from './tracking'\r\n\r\nexport const REDUX_PROXY_LABEL = Symbol()\r\n\r\nlet nextId = 0\r\n\r\nconst proto = Object.getPrototypeOf({})\r\n\r\nclass ObjectTreeNode<T extends Record<string, unknown>> implements Node<T> {\r\n  proxy: T = new Proxy(this, objectProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {} as Record<string, Tag>\r\n  children = {} as Record<string, Node>\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst objectProxyHandler = {\r\n  get(node: Node, key: string | symbol): unknown {\r\n    function calculateResult() {\r\n      const { value } = node\r\n\r\n      const childValue = Reflect.get(value, key)\r\n\r\n      if (typeof key === 'symbol') {\r\n        return childValue\r\n      }\r\n\r\n      if (key in proto) {\r\n        return childValue\r\n      }\r\n\r\n      if (typeof childValue === 'object' && childValue !== null) {\r\n        let childNode = node.children[key]\r\n\r\n        if (childNode === undefined) {\r\n          childNode = node.children[key] = createNode(childValue)\r\n        }\r\n\r\n        if (childNode.tag) {\r\n          consumeTag(childNode.tag)\r\n        }\r\n\r\n        return childNode.proxy\r\n      } else {\r\n        let tag = node.tags[key]\r\n\r\n        if (tag === undefined) {\r\n          tag = node.tags[key] = createTag()\r\n          tag.value = childValue\r\n        }\r\n\r\n        consumeTag(tag)\r\n\r\n        return childValue\r\n      }\r\n    }\r\n    const res = calculateResult()\r\n    return res\r\n  },\r\n\r\n  ownKeys(node: Node): ArrayLike<string | symbol> {\r\n    consumeCollection(node)\r\n    return Reflect.ownKeys(node.value)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    node: Node,\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return Reflect.getOwnPropertyDescriptor(node.value, prop)\r\n  },\r\n\r\n  has(node: Node, prop: string | symbol): boolean {\r\n    return Reflect.has(node.value, prop)\r\n  }\r\n}\r\n\r\nclass ArrayTreeNode<T extends Array<unknown>> implements Node<T> {\r\n  proxy: T = new Proxy([this], arrayProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {}\r\n  children = {}\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst arrayProxyHandler = {\r\n  get([node]: [Node], key: string | symbol): unknown {\r\n    if (key === 'length') {\r\n      consumeCollection(node)\r\n    }\r\n\r\n    return objectProxyHandler.get(node, key)\r\n  },\r\n\r\n  ownKeys([node]: [Node]): ArrayLike<string | symbol> {\r\n    return objectProxyHandler.ownKeys(node)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    [node]: [Node],\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop)\r\n  },\r\n\r\n  has([node]: [Node], prop: string | symbol): boolean {\r\n    return objectProxyHandler.has(node, prop)\r\n  }\r\n}\r\n\r\nexport function createNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  value: T\r\n): Node<T> {\r\n  if (Array.isArray(value)) {\r\n    return new ArrayTreeNode(value)\r\n  }\r\n\r\n  return new ObjectTreeNode(value) as Node<T>\r\n}\r\n\r\nconst keysMap = new WeakMap<\r\n  Array<unknown> | Record<string, unknown>,\r\n  Set<string>\r\n>()\r\n\r\nexport function updateNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  node: Node<T>,\r\n  newValue: T\r\n): void {\r\n  const { value, tags, children } = node\r\n\r\n  node.value = newValue\r\n\r\n  if (\r\n    Array.isArray(value) &&\r\n    Array.isArray(newValue) &&\r\n    value.length !== newValue.length\r\n  ) {\r\n    dirtyCollection(node)\r\n  } else {\r\n    if (value !== newValue) {\r\n      let oldKeysSize = 0\r\n      let newKeysSize = 0\r\n      let anyKeysAdded = false\r\n\r\n      for (const _key in value) {\r\n        oldKeysSize++\r\n      }\r\n\r\n      for (const key in newValue) {\r\n        newKeysSize++\r\n        if (!(key in value)) {\r\n          anyKeysAdded = true\r\n          break\r\n        }\r\n      }\r\n\r\n      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize\r\n\r\n      if (isDifferent) {\r\n        dirtyCollection(node)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const key in tags) {\r\n    const childValue = (value as Record<string, unknown>)[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    if (childValue !== newChildValue) {\r\n      dirtyCollection(node)\r\n      dirtyTag(tags[key], newChildValue)\r\n    }\r\n\r\n    if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      delete tags[key]\r\n    }\r\n  }\r\n\r\n  for (const key in children) {\r\n    const childNode = children[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    const childValue = childNode.value\r\n\r\n    if (childValue === newChildValue) {\r\n      continue\r\n    } else if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      updateNode(childNode, newChildValue as Record<string, unknown>)\r\n    } else {\r\n      deleteNode(childNode)\r\n      delete children[key]\r\n    }\r\n  }\r\n}\r\n\r\nfunction deleteNode(node: Node): void {\r\n  if (node.tag) {\r\n    dirtyTag(node.tag, null)\r\n  }\r\n  dirtyCollection(node)\r\n  for (const key in node.tags) {\r\n    dirtyTag(node.tags[key], null)\r\n  }\r\n  for (const key in node.children) {\r\n    deleteNode(node.children[key])\r\n  }\r\n}\r\n","// Original source:\r\n// - https://github.com/facebook/react/blob/0b974418c9a56f6c560298560265dcf4b65784bc/packages/react/src/ReactCache.js\r\n\r\nimport type {\r\n  AnyFunction,\r\n  DefaultMemoizeFields,\r\n  EqualityFn,\r\n  Simplify\r\n} from './types'\r\n\r\nclass StrongRef<T> {\r\n  constructor(private value: T) {}\r\n  deref() {\r\n    return this.value\r\n  }\r\n}\r\n\r\nconst Ref =\r\n  typeof WeakRef !== 'undefined'\r\n    ? WeakRef\r\n    : (StrongRef as unknown as typeof WeakRef)\r\n\r\nconst UNTERMINATED = 0\r\nconst TERMINATED = 1\r\n\r\ninterface UnterminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 0\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: void\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular Map where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ninterface TerminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 1\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: T\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular `Map` where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ntype CacheNode<T> = TerminatedCacheNode<T> | UnterminatedCacheNode<T>\r\n\r\nfunction createCacheNode<T>(): CacheNode<T> {\r\n  return {\r\n    s: UNTERMINATED,\r\n    v: undefined,\r\n    o: null,\r\n    p: null\r\n  }\r\n}\r\n\r\n/**\r\n * Configuration options for a memoization function utilizing `WeakMap` for\r\n * its caching mechanism.\r\n *\r\n * @template Result - The type of the return value of the memoized function.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport interface WeakMapMemoizeOptions<Result = any> {\r\n  /**\r\n   * If provided, used to compare a newly generated output value against previous values in the cache.\r\n   * If a match is found, the old value is returned. This addresses the common\r\n   * ```ts\r\n   * todos.map(todo => todo.id)\r\n   * ```\r\n   * use case, where an update to another field in the original data causes a recalculation\r\n   * due to changed references, but the output is still effectively the same.\r\n   *\r\n   * @since 5.0.0\r\n   */\r\n  resultEqualityCheck?: EqualityFn<Result>\r\n}\r\n\r\n/**\r\n * Creates a tree of `WeakMap`-based cache nodes based on the identity of the\r\n * arguments it's been called with (in this case, the extracted values from your input selectors).\r\n * This allows `weakMapMemoize` to have an effectively infinite cache size.\r\n * Cache results will be kept in memory as long as references to the arguments still exist,\r\n * and then cleared out as the arguments are garbage-collected.\r\n *\r\n * __Design Tradeoffs for `weakMapMemoize`:__\r\n * - Pros:\r\n *   - It has an effectively infinite cache size, but you have no control over\r\n *   how long values are kept in cache as it's based on garbage collection and `WeakMap`s.\r\n * - Cons:\r\n *   - There's currently no way to alter the argument comparisons.\r\n *   They're based on strict reference equality.\r\n *   - It's roughly the same speed as `lruMemoize`, although likely a fraction slower.\r\n *\r\n * __Use Cases for `weakMapMemoize`:__\r\n * - This memoizer is likely best used for cases where you need to call the\r\n * same selector instance with many different arguments, such as a single\r\n * selector instance that is used in a list item component and called with\r\n * item IDs like:\r\n *   ```ts\r\n *   useSelector(state => selectSomeData(state, props.category))\r\n *   ```\r\n * @param func - The function to be memoized.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @example\r\n * <caption>Using `createSelector`</caption>\r\n * ```ts\r\n * import { createSelector, weakMapMemoize } from 'reselect'\r\n *\r\n * interface RootState {\r\n *   items: { id: number; category: string; name: string }[]\r\n * }\r\n *\r\n * const selectItemsByCategory = createSelector(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category),\r\n *   {\r\n *     memoize: weakMapMemoize,\r\n *     argsMemoize: weakMapMemoize\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @example\r\n * <caption>Using `createSelectorCreator`</caption>\r\n * ```ts\r\n * import { createSelectorCreator, weakMapMemoize } from 'reselect'\r\n *\r\n * const createSelectorWeakMap = createSelectorCreator({ memoize: weakMapMemoize, argsMemoize: weakMapMemoize })\r\n *\r\n * const selectItemsByCategory = createSelectorWeakMap(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category)\r\n * )\r\n * ```\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/weakMapMemoize `weakMapMemoize`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n * @experimental\r\n */\r\nexport function weakMapMemoize<Func extends AnyFunction>(\r\n  func: Func,\r\n  options: WeakMapMemoizeOptions<ReturnType<Func>> = {}\r\n) {\r\n  let fnNode = createCacheNode()\r\n  const { resultEqualityCheck } = options\r\n\r\n  let lastResult: WeakRef<object> | undefined\r\n\r\n  let resultsCount = 0\r\n\r\n  function memoized() {\r\n    let cacheNode = fnNode\r\n    const { length } = arguments\r\n    for (let i = 0, l = length; i < l; i++) {\r\n      const arg = arguments[i]\r\n      if (\r\n        typeof arg === 'function' ||\r\n        (typeof arg === 'object' && arg !== null)\r\n      ) {\r\n        // Objects go into a WeakMap\r\n        let objectCache = cacheNode.o\r\n        if (objectCache === null) {\r\n          cacheNode.o = objectCache = new WeakMap()\r\n        }\r\n        const objectNode = objectCache.get(arg)\r\n        if (objectNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          objectCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = objectNode\r\n        }\r\n      } else {\r\n        // Primitives go into a regular Map\r\n        let primitiveCache = cacheNode.p\r\n        if (primitiveCache === null) {\r\n          cacheNode.p = primitiveCache = new Map()\r\n        }\r\n        const primitiveNode = primitiveCache.get(arg)\r\n        if (primitiveNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          primitiveCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = primitiveNode\r\n        }\r\n      }\r\n    }\r\n\r\n    const terminatedNode = cacheNode as unknown as TerminatedCacheNode<any>\r\n\r\n    let result\r\n\r\n    if (cacheNode.s === TERMINATED) {\r\n      result = cacheNode.v\r\n    } else {\r\n      // Allow errors to propagate\r\n      result = func.apply(null, arguments as unknown as any[])\r\n      resultsCount++\r\n\r\n      if (resultEqualityCheck) {\r\n        const lastResultValue = lastResult?.deref?.() ?? lastResult\r\n\r\n        if (\r\n          lastResultValue != null &&\r\n          resultEqualityCheck(lastResultValue as ReturnType<Func>, result)\r\n        ) {\r\n          result = lastResultValue\r\n\r\n          resultsCount !== 0 && resultsCount--\r\n        }\r\n\r\n        const needsWeakRef =\r\n          (typeof result === 'object' && result !== null) ||\r\n          typeof result === 'function'\r\n\r\n        lastResult = needsWeakRef ? new Ref(result) : result\r\n      }\r\n    }\r\n\r\n    terminatedNode.s = TERMINATED\r\n\r\n    terminatedNode.v = result\r\n    return result\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    fnNode = createCacheNode()\r\n    memoized.resetResultsCount()\r\n  }\r\n\r\n  memoized.resultsCount = () => resultsCount\r\n\r\n  memoized.resetResultsCount = () => {\r\n    resultsCount = 0\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","import { weakMapMemoize } from './weakMapMemoize'\r\n\r\nimport type {\r\n  Combiner,\r\n  CreateSelectorOptions,\r\n  DropFirstParameter,\r\n  ExtractMemoizerFields,\r\n  GetParamsFromSelectors,\r\n  GetStateFromSelectors,\r\n  InterruptRecursion,\r\n  OutputSelector,\r\n  Selector,\r\n  SelectorArray,\r\n  SetRequired,\r\n  Simplify,\r\n  UnknownMemoizer\r\n} from './types'\r\n\r\nimport {\r\n  assertIsFunction,\r\n  collectInputSelectorResults,\r\n  ensureIsArray,\r\n  getDependencies,\r\n  getDevModeChecksExecutionInfo\r\n} from './utils'\r\n\r\n/**\r\n * An instance of `createSelector`, customized with a given memoize implementation.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n * @template StateType - The type of state that the selectors created with this selector creator will operate on.\r\n *\r\n * @public\r\n */\r\nexport interface CreateSelectorFunction<\r\n  MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n  StateType = any\r\n> {\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments and a `combiner` function.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\r\n   */\r\n  <InputSelectors extends SelectorArray<StateType>, Result>(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments, a `combiner` function and an `options` object.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray<StateType>,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions: Simplify<\r\n        CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n      >\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param inputSelectors - An array of input selectors.\r\n   * @param combiner - A function that Combines the input selectors and returns an output selector. Otherwise known as the result function.\r\n   * @param createSelectorOptions - An optional options object that allows for further customization per selector.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray<StateType>,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    inputSelectors: [...InputSelectors],\r\n    combiner: Combiner<InputSelectors, Result>,\r\n    createSelectorOptions?: Simplify<\r\n      CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    >\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a \"pre-typed\" version of {@linkcode createSelector createSelector}\r\n   * where the `state` type is predefined.\r\n   *\r\n   * This allows you to set the `state` type once, eliminating the need to\r\n   * specify it with every {@linkcode createSelector createSelector} call.\r\n   *\r\n   * @returns A pre-typed `createSelector` with the state type already defined.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * import { createSelector } from 'reselect'\r\n   *\r\n   * export interface RootState {\r\n   *   todos: { id: number; completed: boolean }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * export const createAppSelector = createSelector.withTypes<RootState>()\r\n   *\r\n   * const selectTodoIds = createAppSelector(\r\n   *   [\r\n   *     // Type of `state` is set to `RootState`, no need to manually set the type\r\n   *     state => state.todos\r\n   *   ],\r\n   *   todos => todos.map(({ id }) => id)\r\n   * )\r\n   * ```\r\n   * @template OverrideStateType - The specific type of state used by all selectors created with this selector creator.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector#defining-a-pre-typed-createselector `createSelector.withTypes`}\r\n   *\r\n   * @since 5.1.0\r\n   */\r\n  withTypes: <OverrideStateType extends StateType>() => CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction,\r\n    OverrideStateType\r\n  >\r\n}\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param options - An options object containing the `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). It also provides additional options for customizing memoization. While the `memoize` property is mandatory, the rest are optional.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator({\r\n *   memoize: customMemoize, // Function to be used to memoize `resultFunc`\r\n *   memoizeOptions: [memoizeOption1, memoizeOption2], // Options passed to `customMemoize` as the second argument onwards\r\n *   argsMemoize: customArgsMemoize, // Function to be used to memoize the selector's arguments\r\n *   argsMemoizeOptions: [argsMemoizeOption1, argsMemoizeOption2] // Options passed to `customArgsMemoize` as the second argument onwards\r\n * })\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n *\r\n * customSelector(\r\n *   ...selectorArgs // Will be memoized by `customArgsMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-options-since-500 `createSelectorCreator`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n>(\r\n  options: Simplify<\r\n    SetRequired<\r\n      CreateSelectorOptions<\r\n        typeof weakMapMemoize,\r\n        typeof weakMapMemoize,\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      >,\r\n      'memoize'\r\n    >\r\n  >\r\n): CreateSelectorFunction<MemoizeFunction, ArgsMemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param memoize - The `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator(customMemoize, // Function to be used to memoize `resultFunc`\r\n *   option1, // Will be passed as second argument to `customMemoize`\r\n *   option2, // Will be passed as third argument to `customMemoize`\r\n *   option3 // Will be passed as fourth argument to `customMemoize`\r\n * )\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-memoize-and-memoizeoptions `createSelectorCreator`}\r\n *\r\n * @public\r\n */\r\nexport function createSelectorCreator<MemoizeFunction extends UnknownMemoizer>(\r\n  memoize: MemoizeFunction,\r\n  ...memoizeOptionsFromArgs: DropFirstParameter<MemoizeFunction>\r\n): CreateSelectorFunction<MemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization\r\n * function and options for customizing memoization behavior.\r\n *\r\n * @param memoizeOrOptions - Either A `memoize` function or an `options` object containing the `memoize` function.\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n * @template MemoizeOrOptions - The type of the first argument. It can either be a `memoize` function or an `options` object containing the `memoize` function.\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer,\r\n  MemoizeOrOptions extends\r\n    | MemoizeFunction\r\n    | SetRequired<\r\n        CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n        'memoize'\r\n      >\r\n>(\r\n  memoizeOrOptions: MemoizeOrOptions,\r\n  ...memoizeOptionsFromArgs: MemoizeOrOptions extends SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  >\r\n    ? never\r\n    : DropFirstParameter<MemoizeFunction>\r\n) {\r\n  /** options initially passed into `createSelectorCreator`. */\r\n  const createSelectorCreatorOptions: SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  > = typeof memoizeOrOptions === 'function'\r\n    ? {\r\n        memoize: memoizeOrOptions as MemoizeFunction,\r\n        memoizeOptions: memoizeOptionsFromArgs\r\n      }\r\n    : memoizeOrOptions\r\n\r\n  const createSelector = <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: [...InputSelectors],\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions?: CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    ]\r\n  ) => {\r\n    let recomputations = 0\r\n    let dependencyRecomputations = 0\r\n    let lastResult: Result\r\n\r\n    // Due to the intricacies of rest params, we can't do an optional arg after `...createSelectorArgs`.\r\n    // So, start by declaring the default value here.\r\n    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\r\n    let directlyPassedOptions: CreateSelectorOptions<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    > = {}\r\n\r\n    // Normally, the result func or \"combiner\" is the last arg\r\n    let resultFunc = createSelectorArgs.pop() as\r\n      | Combiner<InputSelectors, Result>\r\n      | CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n\r\n    // If the result func is actually an _object_, assume it's our options object\r\n    if (typeof resultFunc === 'object') {\r\n      directlyPassedOptions = resultFunc\r\n      // and pop the real result func off\r\n      resultFunc = createSelectorArgs.pop() as Combiner<InputSelectors, Result>\r\n    }\r\n\r\n    assertIsFunction(\r\n      resultFunc,\r\n      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\r\n    )\r\n\r\n    // Determine which set of options we're using. Prefer options passed directly,\r\n    // but fall back to options given to `createSelectorCreator`.\r\n    const combinedOptions = {\r\n      ...createSelectorCreatorOptions,\r\n      ...directlyPassedOptions\r\n    }\r\n\r\n    const {\r\n      memoize,\r\n      memoizeOptions = [],\r\n      argsMemoize = weakMapMemoize,\r\n      argsMemoizeOptions = [],\r\n      devModeChecks = {}\r\n    } = combinedOptions\r\n\r\n    // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\r\n    // is an array. In most libs I've looked at, it's an equality function or options object.\r\n    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\r\n    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\r\n    // we wrap it in an array so we can apply it.\r\n    const finalMemoizeOptions = ensureIsArray(memoizeOptions)\r\n    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions)\r\n    const dependencies = getDependencies(createSelectorArgs) as InputSelectors\r\n\r\n    const memoizedResultFunc = memoize(function recomputationWrapper() {\r\n      recomputations++\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      return (resultFunc as Combiner<InputSelectors, Result>).apply(\r\n        null,\r\n        arguments as unknown as Parameters<Combiner<InputSelectors, Result>>\r\n      )\r\n    }, ...finalMemoizeOptions) as Combiner<InputSelectors, Result> &\r\n      ExtractMemoizerFields<OverrideMemoizeFunction>\r\n\r\n    let firstRun = true\r\n\r\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\r\n    const selector = argsMemoize(function dependenciesChecker() {\r\n      dependencyRecomputations++\r\n      /** Return values of input selectors which the `resultFunc` takes as arguments. */\r\n      const inputSelectorResults = collectInputSelectorResults(\r\n        dependencies,\r\n        arguments\r\n      )\r\n\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      lastResult = memoizedResultFunc.apply(null, inputSelectorResults)\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        const { identityFunctionCheck, inputStabilityCheck } =\r\n          getDevModeChecksExecutionInfo(firstRun, devModeChecks)\r\n        if (identityFunctionCheck.shouldRun) {\r\n          identityFunctionCheck.run(\r\n            resultFunc as Combiner<InputSelectors, Result>,\r\n            inputSelectorResults,\r\n            lastResult\r\n          )\r\n        }\r\n\r\n        if (inputStabilityCheck.shouldRun) {\r\n          // make a second copy of the params, to check if we got the same results\r\n          const inputSelectorResultsCopy = collectInputSelectorResults(\r\n            dependencies,\r\n            arguments\r\n          )\r\n\r\n          inputStabilityCheck.run(\r\n            { inputSelectorResults, inputSelectorResultsCopy },\r\n            { memoize, memoizeOptions: finalMemoizeOptions },\r\n            arguments\r\n          )\r\n        }\r\n\r\n        if (firstRun) firstRun = false\r\n      }\r\n\r\n      return lastResult\r\n    }, ...finalArgsMemoizeOptions) as unknown as Selector<\r\n      GetStateFromSelectors<InputSelectors>,\r\n      Result,\r\n      GetParamsFromSelectors<InputSelectors>\r\n    > &\r\n      ExtractMemoizerFields<OverrideArgsMemoizeFunction>\r\n\r\n    return Object.assign(selector, {\r\n      resultFunc,\r\n      memoizedResultFunc,\r\n      dependencies,\r\n      dependencyRecomputations: () => dependencyRecomputations,\r\n      resetDependencyRecomputations: () => {\r\n        dependencyRecomputations = 0\r\n      },\r\n      lastResult: () => lastResult,\r\n      recomputations: () => recomputations,\r\n      resetRecomputations: () => {\r\n        recomputations = 0\r\n      },\r\n      memoize,\r\n      argsMemoize\r\n    }) as OutputSelector<\r\n      InputSelectors,\r\n      Result,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    >\r\n  }\r\n\r\n  Object.assign(createSelector, {\r\n    withTypes: () => createSelector\r\n  })\r\n\r\n  return createSelector as CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  >\r\n}\r\n\r\n/**\r\n * Accepts one or more \"input selectors\" (either as separate arguments or a single array),\r\n * a single \"result function\" / \"combiner\", and an optional options object, and\r\n * generates a memoized selector function.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelector `createSelector`}\r\n *\r\n * @public\r\n */\r\nexport const createSelector =\r\n  /* #__PURE__ */ createSelectorCreator(weakMapMemoize)\r\n","import { createSelector } from './createSelectorCreator'\r\n\r\nimport type { CreateSelectorFunction } from './createSelectorCreator'\r\nimport type {\r\n  InterruptRecursion,\r\n  ObjectValuesToTuple,\r\n  OutputSelector,\r\n  Selector,\r\n  Simplify,\r\n  UnknownMemoizer\r\n} from './types'\r\nimport { assertIsObject } from './utils'\r\nimport type { weakMapMemoize } from './weakMapMemoize'\r\n\r\n/**\r\n * Represents a mapping of selectors to their return types.\r\n *\r\n * @template TObject - An object type where each property is a selector function.\r\n *\r\n * @public\r\n */\r\nexport type SelectorResultsMap<TObject extends SelectorsObject> = {\r\n  [Key in keyof TObject]: ReturnType<TObject[Key]>\r\n}\r\n\r\n/**\r\n * Represents a mapping of selectors for each key in a given root state.\r\n *\r\n * This type is a utility that takes a root state object type and\r\n * generates a corresponding set of selectors. Each selector is associated\r\n * with a key in the root state, allowing for the selection\r\n * of specific parts of the state.\r\n *\r\n * @template RootState - The type of the root state object.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport type RootStateSelectors<RootState = any> = {\r\n  [Key in keyof RootState]: Selector<RootState, RootState[Key], []>\r\n}\r\n\r\n/**\r\n * @deprecated Please use {@linkcode StructuredSelectorCreator.withTypes createStructuredSelector.withTypes<RootState>()} instead. This type will be removed in the future.\r\n * @template RootState - The type of the root state object.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport type TypedStructuredSelectorCreator<RootState = any> =\r\n  /**\r\n   * A convenience function that simplifies returning an object\r\n   * made up of selector results.\r\n   *\r\n   * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n   * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n   * @returns A memoized structured selector.\r\n   *\r\n   * @example\r\n   * <caption>Modern Use Case</caption>\r\n   * ```ts\r\n   * import { createSelector, createStructuredSelector } from 'reselect'\r\n   *\r\n   * interface RootState {\r\n   *   todos: {\r\n   *     id: number\r\n   *     completed: boolean\r\n   *     title: string\r\n   *     description: string\r\n   *   }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * // This:\r\n   * const structuredSelector = createStructuredSelector(\r\n   *   {\r\n   *     todos: (state: RootState) => state.todos,\r\n   *     alerts: (state: RootState) => state.alerts,\r\n   *     todoById: (state: RootState, id: number) => state.todos[id]\r\n   *   },\r\n   *   createSelector\r\n   * )\r\n   *\r\n   * // Is essentially the same as this:\r\n   * const selector = createSelector(\r\n   *   [\r\n   *     (state: RootState) => state.todos,\r\n   *     (state: RootState) => state.alerts,\r\n   *     (state: RootState, id: number) => state.todos[id]\r\n   *   ],\r\n   *   (todos, alerts, todoById) => {\r\n   *     return {\r\n   *       todos,\r\n   *       alerts,\r\n   *       todoById\r\n   *     }\r\n   *   }\r\n   * )\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>In your component:</caption>\r\n   * ```tsx\r\n   * import type { RootState } from 'createStructuredSelector/modernUseCase'\r\n   * import { structuredSelector } from 'createStructuredSelector/modernUseCase'\r\n   * import type { FC } from 'react'\r\n   * import { useSelector } from 'react-redux'\r\n   *\r\n   * interface Props {\r\n   *   id: number\r\n   * }\r\n   *\r\n   * const MyComponent: FC<Props> = ({ id }) => {\r\n   *   const { todos, alerts, todoById } = useSelector((state: RootState) =>\r\n   *     structuredSelector(state, id)\r\n   *   )\r\n   *\r\n   *   return (\r\n   *     <div>\r\n   *       Next to do is:\r\n   *       <h2>{todoById.title}</h2>\r\n   *       <p>Description: {todoById.description}</p>\r\n   *       <ul>\r\n   *         <h3>All other to dos:</h3>\r\n   *         {todos.map(todo => (\r\n   *           <li key={todo.id}>{todo.title}</li>\r\n   *         ))}\r\n   *       </ul>\r\n   *     </div>\r\n   *   )\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>Simple Use Case</caption>\r\n   * ```ts\r\n   * const selectA = state => state.a\r\n   * const selectB = state => state.b\r\n   *\r\n   * // The result function in the following selector\r\n   * // is simply building an object from the input selectors\r\n   * const structuredSelector = createSelector(selectA, selectB, (a, b) => ({\r\n   *   a,\r\n   *   b\r\n   * }))\r\n   *\r\n   * const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\r\n   * ```\r\n   *\r\n   * @template InputSelectorsObject - The shape of the input selectors object.\r\n   * @template MemoizeFunction - The type of the memoize function that is used to create the structured selector. It defaults to `weakMapMemoize`.\r\n   * @template ArgsMemoizeFunction - The type of the of the memoize function that is used to memoize the arguments passed into the generated structured selector. It defaults to `weakMapMemoize`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n   */\r\n  <\r\n    InputSelectorsObject extends RootStateSelectors<RootState> = RootStateSelectors<RootState>,\r\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n  >(\r\n    inputSelectorsObject: InputSelectorsObject,\r\n    selectorCreator?: CreateSelectorFunction<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction\r\n    >\r\n  ) => OutputSelector<\r\n    ObjectValuesToTuple<InputSelectorsObject>,\r\n    Simplify<SelectorResultsMap<InputSelectorsObject>>,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n/**\r\n * Represents an object where each property is a selector function.\r\n *\r\n * @template StateType - The type of state that all the selectors operate on.\r\n *\r\n * @public\r\n */\r\nexport type SelectorsObject<StateType = any> = Record<\r\n  string,\r\n  Selector<StateType>\r\n>\r\n\r\n/**\r\n * It provides a way to create structured selectors.\r\n * The structured selector can take multiple input selectors\r\n * and map their output to an object with specific keys.\r\n *\r\n * @template StateType - The type of state that the structured selectors created with this structured selector creator will operate on.\r\n *\r\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n *\r\n * @public\r\n */\r\nexport interface StructuredSelectorCreator<StateType = any> {\r\n  /**\r\n   * A convenience function that simplifies returning an object\r\n   * made up of selector results.\r\n   *\r\n   * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n   * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n   * @returns A memoized structured selector.\r\n   *\r\n   * @example\r\n   * <caption>Modern Use Case</caption>\r\n   * ```ts\r\n   * import { createSelector, createStructuredSelector } from 'reselect'\r\n   *\r\n   * interface RootState {\r\n   *   todos: {\r\n   *     id: number\r\n   *     completed: boolean\r\n   *     title: string\r\n   *     description: string\r\n   *   }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * // This:\r\n   * const structuredSelector = createStructuredSelector(\r\n   *   {\r\n   *     todos: (state: RootState) => state.todos,\r\n   *     alerts: (state: RootState) => state.alerts,\r\n   *     todoById: (state: RootState, id: number) => state.todos[id]\r\n   *   },\r\n   *   createSelector\r\n   * )\r\n   *\r\n   * // Is essentially the same as this:\r\n   * const selector = createSelector(\r\n   *   [\r\n   *     (state: RootState) => state.todos,\r\n   *     (state: RootState) => state.alerts,\r\n   *     (state: RootState, id: number) => state.todos[id]\r\n   *   ],\r\n   *   (todos, alerts, todoById) => {\r\n   *     return {\r\n   *       todos,\r\n   *       alerts,\r\n   *       todoById\r\n   *     }\r\n   *   }\r\n   * )\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>In your component:</caption>\r\n   * ```tsx\r\n   * import type { RootState } from 'createStructuredSelector/modernUseCase'\r\n   * import { structuredSelector } from 'createStructuredSelector/modernUseCase'\r\n   * import type { FC } from 'react'\r\n   * import { useSelector } from 'react-redux'\r\n   *\r\n   * interface Props {\r\n   *   id: number\r\n   * }\r\n   *\r\n   * const MyComponent: FC<Props> = ({ id }) => {\r\n   *   const { todos, alerts, todoById } = useSelector((state: RootState) =>\r\n   *     structuredSelector(state, id)\r\n   *   )\r\n   *\r\n   *   return (\r\n   *     <div>\r\n   *       Next to do is:\r\n   *       <h2>{todoById.title}</h2>\r\n   *       <p>Description: {todoById.description}</p>\r\n   *       <ul>\r\n   *         <h3>All other to dos:</h3>\r\n   *         {todos.map(todo => (\r\n   *           <li key={todo.id}>{todo.title}</li>\r\n   *         ))}\r\n   *       </ul>\r\n   *     </div>\r\n   *   )\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>Simple Use Case</caption>\r\n   * ```ts\r\n   * const selectA = state => state.a\r\n   * const selectB = state => state.b\r\n   *\r\n   * // The result function in the following selector\r\n   * // is simply building an object from the input selectors\r\n   * const structuredSelector = createSelector(selectA, selectB, (a, b) => ({\r\n   *   a,\r\n   *   b\r\n   * }))\r\n   *\r\n   * const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\r\n   * ```\r\n   *\r\n   * @template InputSelectorsObject - The shape of the input selectors object.\r\n   * @template MemoizeFunction - The type of the memoize function that is used to create the structured selector. It defaults to `weakMapMemoize`.\r\n   * @template ArgsMemoizeFunction - The type of the of the memoize function that is used to memoize the arguments passed into the generated structured selector. It defaults to `weakMapMemoize`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n   */\r\n  <\r\n    InputSelectorsObject extends SelectorsObject<StateType>,\r\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n  >(\r\n    inputSelectorsObject: InputSelectorsObject,\r\n    selectorCreator?: CreateSelectorFunction<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction\r\n    >\r\n  ): OutputSelector<\r\n    ObjectValuesToTuple<InputSelectorsObject>,\r\n    Simplify<SelectorResultsMap<InputSelectorsObject>>,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a \"pre-typed\" version of\r\n   * {@linkcode createStructuredSelector createStructuredSelector}\r\n   * where the `state` type is predefined.\r\n   *\r\n   * This allows you to set the `state` type once, eliminating the need to\r\n   * specify it with every\r\n   * {@linkcode createStructuredSelector createStructuredSelector} call.\r\n   *\r\n   * @returns A pre-typed `createStructuredSelector` with the state type already defined.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * import { createStructuredSelector } from 'reselect'\r\n   *\r\n   * export interface RootState {\r\n   *   todos: { id: number; completed: boolean }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * export const createStructuredAppSelector =\r\n   *   createStructuredSelector.withTypes<RootState>()\r\n   *\r\n   * const structuredAppSelector = createStructuredAppSelector({\r\n   *   // Type of `state` is set to `RootState`, no need to manually set the type\r\n   *   todos: state => state.todos,\r\n   *   alerts: state => state.alerts,\r\n   *   todoById: (state, id: number) => state.todos[id]\r\n   * })\r\n   *\r\n   * ```\r\n   * @template OverrideStateType - The specific type of state used by all structured selectors created with this structured selector creator.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createstructuredselector#defining-a-pre-typed-createstructuredselector `createSelector.withTypes`}\r\n   *\r\n   * @since 5.1.0\r\n   */\r\n  withTypes: <\r\n    OverrideStateType extends StateType\r\n  >() => StructuredSelectorCreator<OverrideStateType>\r\n}\r\n\r\n/**\r\n * A convenience function that simplifies returning an object\r\n * made up of selector results.\r\n *\r\n * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n * @returns A memoized structured selector.\r\n *\r\n * @example\r\n * <caption>Modern Use Case</caption>\r\n * ```ts\r\n * import { createSelector, createStructuredSelector } from 'reselect'\r\n *\r\n * interface RootState {\r\n *   todos: {\r\n *     id: number\r\n *     completed: boolean\r\n *     title: string\r\n *     description: string\r\n *   }[]\r\n *   alerts: { id: number; read: boolean }[]\r\n * }\r\n *\r\n * // This:\r\n * const structuredSelector = createStructuredSelector(\r\n *   {\r\n *     todos: (state: RootState) => state.todos,\r\n *     alerts: (state: RootState) => state.alerts,\r\n *     todoById: (state: RootState, id: number) => state.todos[id]\r\n *   },\r\n *   createSelector\r\n * )\r\n *\r\n * // Is essentially the same as this:\r\n * const selector = createSelector(\r\n *   [\r\n *     (state: RootState) => state.todos,\r\n *     (state: RootState) => state.alerts,\r\n *     (state: RootState, id: number) => state.todos[id]\r\n *   ],\r\n *   (todos, alerts, todoById) => {\r\n *     return {\r\n *       todos,\r\n *       alerts,\r\n *       todoById\r\n *     }\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n *\r\n * @public\r\n */\r\nexport const createStructuredSelector: StructuredSelectorCreator =\r\n  Object.assign(\r\n    <\r\n      InputSelectorsObject extends SelectorsObject,\r\n      MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n      ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n    >(\r\n      inputSelectorsObject: InputSelectorsObject,\r\n      selectorCreator: CreateSelectorFunction<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      > = createSelector as CreateSelectorFunction<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      >\r\n    ) => {\r\n      assertIsObject(\r\n        inputSelectorsObject,\r\n        'createStructuredSelector expects first argument to be an object ' +\r\n          `where each property is a selector, instead received a ${typeof inputSelectorsObject}`\r\n      )\r\n      const inputSelectorKeys = Object.keys(inputSelectorsObject)\r\n      const dependencies = inputSelectorKeys.map(\r\n        key => inputSelectorsObject[key]\r\n      )\r\n      const structuredSelector = selectorCreator(\r\n        dependencies,\r\n        (...inputSelectorResults: any[]) => {\r\n          return inputSelectorResults.reduce((composition, value, index) => {\r\n            composition[inputSelectorKeys[index]] = value\r\n            return composition\r\n          }, {})\r\n        }\r\n      )\r\n      return structuredSelector\r\n    },\r\n    { withTypes: () => createStructuredSelector }\r\n  ) as StructuredSelectorCreator\r\n","import { createSelector } from 'reselect';\r\nimport { AppState } from '../rootReducer';\r\n\r\nconst getMainComponent = (state: AppState) => state.mainComponent;\r\n\r\nexport const seriesDataListSelector = createSelector(getMainComponent, (mainComponent: any) => mainComponent.seriesDataList);\r\nexport const selectedSeriesDataSelector = createSelector(getMainComponent, (mainComponent: any) => mainComponent.selectedSeriesData);\r\n\r\n","import React, { useState } from 'react';\r\nimport styled from 'styled-components';\r\n\r\nconst SearchBarWrapper = styled.div`\r\n    background-color: #e9e9e9;\r\n    display: flex;\r\n    padding: 10px;\r\n    input[type=text] {\r\n        font-size: 1.2rem;\r\n        flex-grow: 1; \r\n  }\r\n  button{\r\n    padding: 6px 10px;\r\n    background: #ddd;\r\n    font-size: 1.2rem;\r\n    border: none;\r\n    cursor: pointer;\r\n  }\r\n   button:hover{background: #ccc;} \r\n  .topnav input[type=text] {\r\n    border: 1px solid #ccc; \r\n    \r\n  }\r\n`;\r\ntype searchBarProps = {\r\n    name: string,\r\n    setName: React.Dispatch<React.SetStateAction<string>>,\r\n    onSortByClickCB: (value: string) => void,\r\n}\r\nconst SearchBar: React.FC<searchBarProps> = ({ name, setName, onSortByClickCB }) => {\r\n  const [visibleSortBy, setVisibleSortBy] = useState(false);\r\n  const [sortBy, setSortBy] = useState<string>('');\r\n\r\n  const onChangeHandler = ({target:{ value }}:any) => {\r\n    setSortBy(value); \r\n    onSortByClickCB(value);\r\n  };\r\n    return (\r\n        <SearchBarWrapper className=\"seach-wrapper\">\r\n          <button type=\"button\" onClick={() => setVisibleSortBy((prev) => !prev)}>Sort By...</button>\r\n          {visibleSortBy && (<div>\r\n          <fieldset>\r\n            <label><input type=\"checkbox\" name=\"sortBy\" value=\"year\" checked={sortBy === 'year'} onChange={onChangeHandler} /> Year</label>\r\n            <label><input type=\"checkbox\" name=\"sortBy\" value=\"episode\" checked={sortBy === 'episode'} onChange={onChangeHandler} /> Episode</label>\r\n          </fieldset>\r\n          </div>)}\r\n          <input type=\"text\" placeholder=\"Search by episode or title...\" name=\"search\" value={name} onChange={({target: { value }}) => setName(value)} />\r\n        </SearchBarWrapper>\r\n    );\r\n};\r\n\r\nexport default SearchBar;","import React, { useEffect } from 'react';\r\nimport { convertIntToRoman } from '../../utils/utilityFunction';\r\nimport styled from 'styled-components';\r\nimport LoadingComponent from 'components/loading';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport { getSelectedSeriesData } from '../../redux/main-component/action';\r\nimport { selectedSeriesDataSelector } from '../../redux/main-component/selector';\r\n\r\nconst DetailViewWrapper = styled.div`\r\n    flex-basis: 65%;\r\n    padding: 0.8rem;\r\n    .image-wrapper {\r\n        display: flex;\r\n        justify-content: flex-start;\r\n        & img{\r\n            width: 120px;\r\n        }\r\n        & .content{\r\n            padding: 0 0.8rem;\r\n        }    \r\n    }\r\n`;\r\n\r\nconst CloseBtn = styled.button`\r\n    background: none;\r\n    border: none;\r\n    padding: 0px;\r\n    margin-right: 1rem;\r\n    vertical-align: top;\r\n    width: 20px;\r\n    height: 20px;\r\n    margin: 0px;\r\n    cursor: pointer;\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n`;\r\n\r\n\r\nconst CloseBtnWrapper = ({ setDetailViewVisible }:any) => (\r\n    <CloseBtn\r\n      className=\"close-btn\"\r\n      type=\"button\"\r\n      onClick={() => setDetailViewVisible(false)}\r\n    >\r\n      <svg className=\"cross__svg\" xmlns=\"http://www.w3.org/2000/svg\">\r\n        <path d=\"M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z\" fill=\"#000000\" />\r\n      </svg>\r\n    </CloseBtn>\r\n  );\r\n\r\nconst DetailedView = ({ selectedSeriesData, rowData, setDetailViewVisible }: any) => (\r\n    <div style={{ position: 'relative' }}>\r\n        <CloseBtnWrapper {...{ setDetailViewVisible }}/>\r\n        <h2>EPISODE {convertIntToRoman(rowData.episode_id)} - {rowData.title}</h2>\r\n        <div className='image-wrapper'>\r\n            <div><img src={selectedSeriesData.Poster} alt={`${selectedSeriesData.Title} image`} loading=\"lazy\" /></div>\r\n            <div className='content'>{rowData.opening_crawl}</div>\r\n        </div>\r\n        <p>Directed By: {rowData.producer}</p>\r\n    </div>\r\n);\r\n\r\nconst DetailedViewComp = ({ data: rowData, setDetailViewVisible }:any) => {\r\n    const dispatch = useDispatch();\r\n    const { loading, error, data: selectedSeriesData } = useSelector(selectedSeriesDataSelector);\r\n    useEffect(() =>{\r\n        if (selectedSeriesData.Title?.toLowerCase() !== rowData.title?.toLowerCase())\r\n        dispatch(getSelectedSeriesData({ title: rowData.title, year: rowData.release_date.split('-').at(0) }));\r\n    }, [rowData]);\r\n    \r\n    return (\r\n        <DetailViewWrapper>\r\n            { loading && <div className='loading'><LoadingComponent /></div>}\r\n            {error && <div>Error: {error}</div>}\r\n            { !loading && !error && <DetailedView {...{ selectedSeriesData, rowData, setDetailViewVisible }} />}\r\n        </DetailViewWrapper>\r\n    )\r\n};\r\n\r\nexport default DetailedViewComp;","import React, { useState } from 'react';\r\nimport styled from 'styled-components';\r\nimport DetailedView from './detailedView';\r\nimport { tableProps } from './types';\r\n\r\nconst WrapperComp = styled.div`\r\n    display: flex;\r\n    justify-content: flex-start;\r\n    & > div{\r\n        flex-basis: 100%;\r\n    }\r\n`;\r\nconst TableComp = styled.table `\r\n    border-collapse: collapse;\r\n    box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);\r\n    width: 100%;\r\n    & > thead tr {\r\n        background-color: #009879;\r\n        color: #ffffff;\r\n        text-align: left;\r\n    }\r\n    & tr > th, tr > td {\r\n        padding: 12px 15px;\r\n    }\r\n    & > tbody tr {\r\n        cursor: pointer;\r\n        border-bottom: 1px solid #dddddd;\r\n    }\r\n    & > tbody tr.selected{background-color: #ccc;}    \r\n    & > tbody tr:last-of-type {\r\n        border-bottom: 2px solid #009879;\r\n    }\r\n    & > tbody tr.active-row {\r\n        font-weight: bold;\r\n        color: #009879;\r\n    }\r\n    & > tbody tr:hover{background-color: rgba(0, 0, 0, 0.4);}\r\n`;\r\n\r\nconst Table: React.FC<tableProps> = ({ columns, data }) => {\r\n    const [detailedView, setDetailedView] = useState<any>(null);\r\n    const [detailViewVisible, setDetailViewVisible] = useState<boolean>(false); \r\n    const handleRowClick = (data:any) => { \r\n        setDetailedView(data);\r\n        setDetailViewVisible(true);\r\n    } \r\n    return (\r\n        <WrapperComp>\r\n            <div>\r\n                <TableComp>\r\n                    <thead>\r\n                        <tr>\r\n                            {React.Children.toArray(columns.map((v:any) => <th>{v.label}</th>))}\r\n                        </tr>\r\n                    </thead>\r\n                    <tbody>\r\n                        {\r\n                            React.Children.toArray(data.map((data:any) => \r\n                                <tr onClick={() => handleRowClick(data)} className={detailedView && data.episode_id === detailedView.episode_id ? 'selected' : ''}>\r\n                                    {React.Children.toArray(columns.map((col:any) => (\r\n                                        <td>{col.render(data)}</td>\r\n                                    )))}\r\n                                </tr>\r\n                            ))\r\n                        }\r\n                    </tbody>\r\n                </TableComp>\r\n            </div>\r\n            { detailViewVisible && <DetailedView {...{ data: detailedView, setDetailViewVisible }} />}\r\n        </WrapperComp>\r\n    );\r\n};\r\n\r\nexport default Table;","import React, { useEffect, useState } from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport { seriesDataListSelector } from '../../redux/main-component/selector';\r\nimport { convertIntToRoman } from '../../utils/utilityFunction';\r\nimport { getSeriesDataList } from '../../redux/main-component/action';\r\nimport SearchBar from 'components/searchBar';\r\nimport Table from 'components/table';\r\nimport Loading from 'components/loading';\r\nimport styled from 'styled-components';\r\nimport { SeriesListResponse } from 'redux/main-component/types';\r\n\r\ntype columnType = {\r\n    label: string,\r\n    key: string,\r\n    type: 'TEXT' | 'NUMBER' | 'IMAGE',\r\n    render: (data:any) => React.ReactNode, \r\n}\r\n\r\n\r\nconst columns: Array<columnType> = [\r\n    {label: 'Episode', key: 'episode_id', type: 'TEXT', render: (data) => (<span>EPISODE {data.episode_id}</span>)},\r\n    {label: 'Episode - Title', key: 'episode-title', type: 'TEXT', render: (data) => (<span>EPISODE {convertIntToRoman(data.episode_id)} - {data.title}</span>)},\r\n    {label: 'Release Date', key: 'release_date', type: 'TEXT', render: (data) => (<span>{data.release_date}</span>)}\r\n];\r\n\r\nconst NoDataFound =  styled.div`\r\n    background: #f44336;\r\n    color: #FFFFFF;\r\n    text-align: center;\r\n    padding: 5px;\r\n`;\r\n\r\nconst MainComponent = () => {\r\n    const dispatch = useDispatch();\r\n    const [name, setName] = useState<string>('');\r\n    const { data: seriesDataList, error: seriesError, loading: seriesLoading } = useSelector(seriesDataListSelector);\r\n    const [filteredDataList, setFilteredDataList] = useState<Array<SeriesListResponse>>([]);\r\n\r\n    useEffect(() => {\r\n        dispatch(getSeriesDataList());\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        if (!seriesLoading && seriesDataList.length) setFilteredDataList(seriesDataList);\r\n    }, [seriesLoading, seriesDataList]);\r\n\r\n    useEffect(() => {\r\n        if(name && name.length >= 3) {\r\n            const sd = seriesDataList.filter((v:any) => {\r\n                const title = v.title.toLowerCase();\r\n                return title.includes(name.toLowerCase());\r\n            });\r\n            setFilteredDataList(sd);\r\n        }else{\r\n            setFilteredDataList(seriesDataList);\r\n        }\r\n    }, [name]);\r\n    const onSortByClickCB = (value: string) => {\r\n        const sortBy:any = value === 'year' ? 'release_date': 'episode_id';\r\n        const sortedData = value === 'year' ? filteredDataList.sort((a:any, b:any) => new Date(a[sortBy]).valueOf() - new Date(b[sortBy]).valueOf()) : filteredDataList.sort((a:any, b:any) => a[sortBy] - b[sortBy]);\r\n        setFilteredDataList([...sortedData]);\r\n    };\r\n    \r\n    return (\r\n        <div>\r\n            <h3>Implementation of Movie/Series Dashboard</h3>\r\n            <SearchBar {...{ name, setName, onSortByClickCB }}/>\r\n            <div style={{ height: '75vh', overflow: 'auto'}}>\r\n                {seriesError && <div>Error: {seriesError}</div>}\r\n                {\r\n                    seriesLoading ? <Loading /> : (Array.isArray(filteredDataList) && filteredDataList.length) ? <Table {...{ columns, data: filteredDataList }}/> : <NoDataFound>No Data Found!</NoDataFound>\r\n                }\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default MainComponent;"],"names":["assertIsFunction","func","TypeError","arguments","length","undefined","ensureIsArray","item","Array","isArray","getDependencies","createSelectorArgs","dependencies","array","errorMessage","every","itemTypes","map","name","join","assertIsArrayOfFunctions","Symbol","Object","getPrototypeOf","Ref","WeakRef","constructor","value","deref","this","weakMapMemoize","options","fnNode","s","v","o","p","resultEqualityCheck","lastResult","resultsCount","memoized","cacheNode","i","l","arg","objectCache","WeakMap","objectNode","get","set","primitiveCache","Map","primitiveNode","terminatedNode","result","apply","lastResultValue","clearCache","resetResultsCount","createSelectorCreator","memoizeOrOptions","_len","memoizeOptionsFromArgs","_key2","createSelectorCreatorOptions","memoize","memoizeOptions","createSelector2","_len2","_key3","recomputations","dependencyRecomputations","directlyPassedOptions","resultFunc","pop","combinedOptions","argsMemoize","argsMemoizeOptions","devModeChecks","finalMemoizeOptions","finalArgsMemoizeOptions","memoizedResultFunc","selector","inputSelectorResults","inputSelectorArgs","push","collectInputSelectorResults","assign","resetDependencyRecomputations","resetRecomputations","withTypes","createSelector","createStructuredSelector","inputSelectorsObject","selectorCreator","object","assertIsObject","inputSelectorKeys","keys","structuredSelector","key","_len3","_key4","reduce","composition","index","getMainComponent","state","mainComponent","seriesDataListSelector","seriesDataList","selectedSeriesDataSelector","selectedSeriesData","SearchBarWrapper","styled","div","_ref","setName","onSortByClickCB","visibleSortBy","setVisibleSortBy","useState","sortBy","setSortBy","onChangeHandler","_ref2","target","_jsxs","className","children","_jsx","type","onClick","prev","checked","onChange","placeholder","_ref3","DetailViewWrapper","CloseBtn","button","CloseBtnWrapper","setDetailViewVisible","xmlns","d","fill","DetailedView","rowData","style","position","convertIntToRoman","episode_id","title","src","Poster","alt","Title","loading","opening_crawl","producer","data","dispatch","useDispatch","error","useSelector","useEffect","_selectedSeriesData$T","_rowData$title","toLowerCase","getSelectedSeriesData","year","release_date","split","at","LoadingComponent","WrapperComp","TableComp","table","columns","detailedView","setDetailedView","detailViewVisible","React","toArray","label","handleRowClick","col","render","NoDataFound","MainComponent","seriesError","seriesLoading","filteredDataList","setFilteredDataList","getSeriesDataList","sd","filter","includes","SearchBar","sortedData","sort","a","b","Date","valueOf","height","overflow","Loading","Table"],"sourceRoot":""}